#!/usr/bin/env python

import rospy
import smach
import smach_ros

from rosplan_tiago_active_human_fall_prevention.msg import HumanApproachDetectAction
from rosplan_tiago_active_human_fall_prevention.msg import HumanApproachDetectActionGoal
from rosplan_tiago_active_human_fall_prevention.msg import HumanApproachDetectActionFeedback
from rosplan_tiago_active_human_fall_prevention.msg import HumanApproachDetectActionResult
from rosplan_knowledge_msgs.srv import *
from rosplan_knowledge_msgs.msg import *
from rosplan_dispatch_msgs.srv import *
from rosplan_dispatch_msgs.msg import *
from std_srvs.srv import *


class Initialize(smach.State):
    def __init__(self):
        smach.State.__init__(self,
                             outcomes=['ok', 'preemption', 'error'],
                             input_keys=['init_goal'],
                             output_keys=['init_feedback',
                                          'init_item',
                                          'init_params'])

    def execute(self, userdata):
        rospy.loginfo('Executing state: {}'.format(self.__class__.__name__))

        # take goal, check values, split into pose and params, check if params are okay
        # now the server receives only pose
        goal = userdata.init_goal.blind_goal

        userdata.init_item = goal

        rospy.sleep(1)
        return 'ok'


class Dummy(smach.State):
    def __init__(self):
        smach.State.__init__(self,
                             outcomes=['ok', 'preemption', 'error'],
                             input_keys=['dummy_goal',
                                         'dummy_params'],
                             output_keys=['dummy_feedback',
                                          'dummy_info'])

    def rosplan_problem_generation(self):
        print "Waiting for service"
        rospy.wait_for_service('rosplan_problem_interface/problem_generation_server')

        print "Preparing the message"
        request_problem = EmptyRequest()

        try:
            print "Calling Problem Generation Service"
            proxy = rospy.ServiceProxy('rosplan_problem_interface/problem_generation_server', Empty)
            update_response = proxy(request_problem)
            print "Response is: ", update_response
        except rospy.ServiceException, e:
            print "Service call failed: %s"%e

    def rosplan_planning(self):
        print "Waiting for service"
        rospy.wait_for_service('rosplan_planner_interface/planning_server')

        print "Preparing the message"
        request_planner = EmptyRequest()

        try:
            print "Calling Planning Service"
            proxy = rospy.ServiceProxy('rosplan_planner_interface/planning_server', Empty)
            update_response = proxy(request_planner)
            print "Response is: ", update_response
        except rospy.ServiceException, e:
            print "Service call failed: %s"%e

    def rosplan_parse_plan(self):
        print "Waiting for service"
        rospy.wait_for_service('rosplan_parsing_interface/parse_plan')

        print "Preparing the message"
        request_parser = EmptyRequest()

        try:
            print "Calling Parse Plan"
            proxy = rospy.ServiceProxy('rosplan_parsing_interface/parse_plan', Empty)
            update_response = proxy(request_parser)
            print "Response is: ", update_response
        except rospy.ServiceException, e:
            print "Service call failed: %s"%e

    def rosplan_dispatch_plan(self):
        print "Waiting for service"
        rospy.wait_for_service('rosplan_plan_dispatcher/dispatch_plan')

        print "Preparing the message"
        request_dispatcher = EmptyRequest()

        try:
            print "Calling Dispatch Plan"
            proxy = rospy.ServiceProxy('rosplan_plan_dispatcher/dispatch_plan', Empty)
            update_response = proxy(request_dispatcher)
            print "Response is: ", update_response
        except rospy.ServiceException, e:
            print "Service call failed: %s"%e

    def rosplan_stop_dispatch(self):
        print "Waiting for service"
        rospy.wait_for_service('rosplan_plan_dispatcher/cancel_dispatch')

        print "Preparing the message"
        request_dispatcher = EmptyRequest()

        try:
            print "Calling Cancel Dispatch Plan"
            proxy = rospy.ServiceProxy('rosplan_plan_dispatcher/cancel_dispatch', Empty)
            print "czy tu sie wypierdala?"
            update_response = proxy(request_dispatcher)
            print "Response is: ", update_response
        except rospy.ServiceException, e:
            print "Service call failed: %s"%e

    def kb_add_remove_human(self, name, location, add=True):
        print "Waiting for service"
        rospy.wait_for_service('rosplan_knowledge_base/update')

        print "Preparing the message"
        item = KnowledgeUpdateServiceRequest()
        if add == True:
            item.update_type = KnowledgeUpdateServiceRequest.ADD_KNOWLEDGE
        else:
            item.update_type = KnowledgeUpdateServiceRequest.REMOVE_KNOWLEDGE

        item.knowledge.knowledge_type = KnowledgeItem.FACT
        item.knowledge.attribute_name = "at"
        item.knowledge.values.append(diagnostic_msgs.msg.KeyValue("obj", name))
        item.knowledge.values.append(diagnostic_msgs.msg.KeyValue("loc", location))

        try:
            print "Calling Service"
            update_proxy = rospy.ServiceProxy('rosplan_knowledge_base/update', KnowledgeUpdateService)
            update_response = update_proxy(item)
            print "Response is: ", update_response.success
        except rospy.ServiceException, e:
            print "Service call failed: %s"%e

    def kb_add_remove_goals(self, attribute, keys, list_key_value, add=True, negation=False):
        print "Waiting for service"
        rospy.wait_for_service('rosplan_knowledge_base/update_array')

        print "Preparing the message"
        items = KnowledgeUpdateServiceArrayRequest()
        temp_item_update_type = []

        for dict in list_key_value:
            if add == True:
                temp_item_update_type.append(KnowledgeUpdateServiceArrayRequest.ADD_GOAL)
            else:
                temp_item_update_type.append(KnowledgeUpdateServiceArrayRequest.REMOVE_GOAL)

            temp_item_knowledge = KnowledgeUpdateServiceRequest().knowledge
            temp_item_knowledge.knowledge_type = KnowledgeItem.FACT
            temp_item_knowledge.attribute_name = attribute
            temp_item_knowledge.is_negative = negation
            for key in keys:
                temp_item_knowledge.values.append(diagnostic_msgs.msg.KeyValue(key, dict[key]))

            items.knowledge.append(temp_item_knowledge)
            items.update_type = temp_item_update_type

        try:
            print "Calling Service"
            update_proxy = rospy.ServiceProxy('rosplan_knowledge_base/update_array', KnowledgeUpdateServiceArray)
            update_response = update_proxy(items)
            print "Response is: ", update_response.success
        except rospy.ServiceException, e:
            print "Service call failed: %s"%e

    def kb_add_remove_knowledge(self, attribute, keys, list_key_value, add=True, negation=False):
        print "Waiting for service"
        rospy.wait_for_service('rosplan_knowledge_base/update_array')

        print "Preparing the message"
        items = KnowledgeUpdateServiceArrayRequest()
        temp_item_update_type = []

        for dict in list_key_value:
            if add == True:
                temp_item_update_type.append(KnowledgeUpdateServiceArrayRequest.ADD_KNOWLEDGE)
            else:
                temp_item_update_type.append(KnowledgeUpdateServiceArrayRequest.REMOVE_KNOWLEDGE)

            temp_item_knowledge = KnowledgeUpdateServiceRequest().knowledge
            temp_item_knowledge.knowledge_type = KnowledgeItem.FACT
            temp_item_knowledge.attribute_name = attribute
            temp_item_knowledge.is_negative = negation
            for key in keys:
                temp_item_knowledge.values.append(diagnostic_msgs.msg.KeyValue(key, dict[key]))

            items.knowledge.append(temp_item_knowledge)
            items.update_type = temp_item_update_type

        try:
            print "Calling Service"
            update_proxy = rospy.ServiceProxy('rosplan_knowledge_base/update_array', KnowledgeUpdateServiceArray)
            update_response = update_proxy(items)
            print "Response is: ", update_response.success
        except rospy.ServiceException, e:
            print "Service call failed: %s"%e


    def execute(self, userdata):
        rospy.loginfo('Executing state: {}'.format(self.__class__.__name__))

        # robot movement here - using Tiago move_base
        goal = userdata.dummy_goal
        print goal

        #rospy.sleep(10)

        # remove scanning area goals
        key_value = []
        for i in range(6):
            temp_dict = dict()
            temp_dict.update({"loc_from": "wp{}".format(i)})
            temp_dict.update({"loc_to": "wp{}".format(i+1)})
            key_value.append(temp_dict)

        keys = ["loc_from", "loc_to"]
        self.kb_add_remove_goals("scanned_area", keys, key_value, add=False)

        # remove human_detection_ongoing
        self.kb_add_remove_goals("human_detection_ongoing", ["human"], [{"human": "luke"}], add=False)

        # add human_informed goal
        self.kb_add_remove_goals("human_informed", ["human"], [{"human": "luke"}], add=True)

        # handle "human_coming" fact
        self.kb_add_remove_knowledge("human_coming", ["human"], [{"human": "luke"}], add=True)
        self.kb_add_remove_knowledge("not_human_coming", ["human"], [{"human": "luke"}], add=True, negation=True)
        self.kb_add_remove_knowledge("human_coming", ["human"], [{"human": "luke"}], add=False, negation=True)
        self.kb_add_remove_knowledge("not_human_coming", ["human"], [{"human": "luke"}], add=False)
        # TODO HERE IS ERROR ^^^ Should be without "luke" (check domain)


        self.rosplan_stop_dispatch()
        self.rosplan_problem_generation()
        self.rosplan_planning()
        self.rosplan_parse_plan()
        self.rosplan_dispatch_plan()

        # now exit gently by returning smach ending code
        rospy.sleep(3)
        return 'ok'


class Finalize(smach.State):
    def __init__(self):
        smach.State.__init__(self,
                             outcomes=['ok', 'preemption', 'error'],
                             input_keys=['final_info'],
                             output_keys=['final_feedback',
                                          'final_result'])

    def execute(self, userdata):
        rospy.loginfo('Executing state: {}'.format(self.__class__.__name__))

        # prepare some feedback & result
        action_feedback = HumanApproachDetectActionFeedback()
        action_feedback.feedback.percent_complete = 8
        userdata.final_feedback = action_feedback.feedback

        action_result = HumanApproachDetectActionResult()
        action_result.result.is_undocked = 1
        userdata.final_result = action_result.result

        # robot approach check may be put here, some distances calculated
        rospy.sleep(2)
        return 'ok'


class HumanApproachDetectServer(smach.StateMachine):
    def __init__(self):
        smach.StateMachine.__init__(self,
                                    outcomes=['PREEMPTED',
                                              'FAILED',
                                              'SM_SUCCEEDED'],
                                    input_keys=['sm_goal'],
                                    output_keys=['sm_feedback',
                                                 'sm_result'])

        # Fill the machine here
        with self:
            smach.StateMachine.add('Initialize',
                                   Initialize(),
                                   transitions={'ok': 'Dummy',
                                                'preemption': 'PREEMPTED',
                                                'error': 'FAILED'},
                                   remapping={'init_goal': 'sm_goal',
                                              'init_feedback': 'sm_feedback',
                                              'init_item': 'sm_goal',
                                              'init_params': 'sm_params'})

            smach.StateMachine.add('Dummy',
                                   Dummy(),
                                   transitions={'ok': 'Finalize',
                                                'preemption': 'PREEMPTED',
                                                'error': 'FAILED'},
                                   remapping={'dummy_goal': 'sm_goal',
                                              'dummy_params': 'sm_params',
                                              'dummy_feedback': 'sm_feedback',
                                              'dummy_info': 'sm_info'})

            smach.StateMachine.add('Finalize',
                                   Finalize(),
                                   transitions={'preemption': 'PREEMPTED',
                                                'error': 'FAILED',
                                                'ok': 'SM_SUCCEEDED'},
                                   remapping={'final_info': 'sm_info',
                                              'final_feedback': 'sm_feedback',
                                              'final_result': 'sm_result'})


def main():
    rospy.init_node('human_approach_detect_server')

    # Construct state machine
    sm = HumanApproachDetectServer()

    # # Smach viewer
    sis = smach_ros.IntrospectionServer('human_approach_detect_server', sm, '/SM_HUMAN_APPROACH_DETECT_SERVER')
    sis.start()

    # Construct action server wrapper
    asw = smach_ros.ActionServerWrapper(
        server_name='human_approach_detect',
        action_spec=HumanApproachDetectAction,
        wrapped_container=sm,
        succeeded_outcomes=['SM_SUCCEEDED'],
        aborted_outcomes=['FAILED'],
        preempted_outcomes=['PREEMPTED'],
        goal_key='sm_goal',
        feedback_key='sm_feedback',
        result_key='sm_result')

    # Run the server in a background thread
    asw.run_server()
    rospy.spin()
    sis.stop()


if __name__ == '__main__':
    main()
